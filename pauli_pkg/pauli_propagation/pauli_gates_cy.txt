# -*- coding: utf-8 -*-
# pauli_pkg/pauli_propagation/su4_gate_cy.pyx
# cython: language_level=3, boundscheck=False, wraparound=False, nonecheck=False

import numpy as np
cimport numpy as cnp
from libc.math cimport fabs

# Precompute 2-qubit Pauli basis
_SINGLE_P = (
    np.eye(2, dtype=np.complex128),
    np.array([[0,1],[1,0]],    dtype=np.complex128),
    np.array([[0,-1j],[1j,0]], dtype=np.complex128),
    np.array([[1,0],[0,-1]],   dtype=np.complex128),
)
P_STACK = np.stack(
    [np.kron(_SINGLE_P[q2], _SINGLE_P[q1])
     for q2 in range(4) for q1 in range(4)],
    dtype=np.complex128
)

cdef inline int _code_from_bits(int z, int x):
    return (z << 1) | x if z == 0 else (2 | (x ^ 1))


cpdef object su4_gate_cy(complex coeff,
                         unsigned long long key,
                         int n, int q1, int q2,
                         object mat):
    """
    Cython©\accelerated SU4 back©\propagation.  
    Returns (L, coeffs, keys) exactly like the Python version.
    """

    # 1) compute Pauli index
    cdef int x1 = (key >>  q1)    & 1
    cdef int z1 = (key >> (n+q1)) & 1
    cdef int x2 = (key >>  q2)    & 1
    cdef int z2 = (key >> (n+q2)) & 1
    cdef int beta_idx = 4*_code_from_bits(z2, x2) + _code_from_bits(z1, x1)

    # 2) conjugate in pure©\Python/NumPy
    U = mat  # np.ndarray
    conj = U.conj().T @ P_STACK[beta_idx] @ U

    # 3) expand into Pauli basis via einsum
    coeffs_np = 0.25 * np.einsum(
        'aij,ij->a',
        P_STACK.conj(), conj,
        optimize=True
    )

    # 4) collect nonzero terms with correct bit©\flips
    cdef cnp.ndarray[cnp.complex128_t, ndim=1] coeff_out = \
        np.empty(16, dtype=np.complex128)
    cdef object[:] key_out = np.empty(16, dtype=object)
    cdef int L = 0
    cdef int alpha, code1a, code2a, zbit, xbit
    cdef unsigned long long new_key
    cdef complex cval

    for alpha in range(16):
        cval = coeff * coeffs_np[alpha]
        if fabs(cval.real) + fabs(cval.imag) < 1e-12:
            continue

        new_key = key
        code2a = alpha // 4
        code1a = alpha  % 4

        # decode for first qubit
        if code1a == 0:
            zbit = 0; xbit = 0
        elif code1a == 1:
            zbit = 0; xbit = 1
        elif code1a == 2:
            zbit = 1; xbit = 1
        else:
            zbit = 1; xbit = 0

        if ((new_key >>  q1) & 1) != xbit:
            new_key ^= 1 <<  q1
        if ((new_key >> (n+q1)) & 1) != zbit:
            new_key ^= 1 << (n+q1)

        # decode for second qubit
        if code2a == 0:
            zbit = 0; xbit = 0
        elif code2a == 1:
            zbit = 0; xbit = 1
        elif code2a == 2:
            zbit = 1; xbit = 1
        else:
            zbit = 1; xbit = 0

        if ((new_key >>  q2) & 1) != xbit:
            new_key ^= 1 <<  q2
        if ((new_key >> (n+q2)) & 1) != zbit:
            new_key ^= 1 << (n+q2)

        coeff_out[L] = cval
        key_out[L]   = new_key
        L += 1

    return L, coeff_out[:L], key_out[:L]
